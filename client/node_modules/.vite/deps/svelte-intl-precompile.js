import "./chunk-WPFU6BGY.js";
import "./chunk-7BG4I5KW.js";
import {
  derived,
  writable
} from "./chunk-FUDYPMMF.js";
import "./chunk-U7P2NEEE.js";
import "./chunk-G32LTXPZ.js";
import "./chunk-UVGOQMON.js";
import "./chunk-UKRL22FA.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-3F74YA3Z.js";

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/utils.js
var defaultFormats = {
  number: {
    scientific: { notation: "scientific" },
    engineering: { notation: "engineering" },
    compactLong: { notation: "compact", compactDisplay: "long" },
    compactShort: { notation: "compact", compactDisplay: "short" }
  },
  date: {
    short: { month: "numeric", day: "numeric", year: "2-digit" },
    medium: { month: "short", day: "numeric", year: "numeric" },
    long: { month: "long", day: "numeric", year: "numeric" },
    full: { weekday: "long", month: "long", day: "numeric", year: "numeric" }
  },
  time: {
    short: { hour: "numeric", minute: "numeric" },
    medium: { hour: "numeric", minute: "numeric", second: "numeric" },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    }
  }
};
var defaultOptions = {
  fallbackLocale: "",
  initialLocale: "",
  loadingDelay: 200,
  formats: defaultFormats,
  warnOnMissingMessages: true
};
var options = defaultOptions;
var currentLocale;
function getCurrentLocale() {
  return currentLocale;
}
function setCurrentLocale(val) {
  return currentLocale = val;
}
function getOptions() {
  return options;
}
function getSubLocales(refLocale) {
  return refLocale.split("-").map((_, i, arr) => arr.slice(0, i + 1).join("-")).reverse();
}
function getPossibleLocales(refLocale, fallbackLocale = getOptions().fallbackLocale) {
  const locales = getSubLocales(refLocale);
  if (fallbackLocale) {
    return [.../* @__PURE__ */ new Set([...locales, ...getSubLocales(fallbackLocale)])];
  }
  return locales;
}

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/stores/dictionary.js
var dictionary;
var $dictionary = writable({});
function getLocaleDictionary(locale) {
  return dictionary[locale] || null;
}
function hasLocaleDictionary(locale) {
  return locale in dictionary;
}
function getMessageFromDictionary(locale, id) {
  if (hasLocaleDictionary(locale)) {
    const localeDictionary = getLocaleDictionary(locale);
    if (id in localeDictionary) {
      return localeDictionary[id];
    }
    const ids = id.split(".");
    let tmpDict = localeDictionary;
    for (let i = 0; i < ids.length; i++) {
      if (typeof tmpDict[ids[i]] !== "object") {
        return tmpDict[ids[i]] || null;
      }
      tmpDict = tmpDict[ids[i]];
    }
    return tmpDict;
  }
  return null;
}
function getClosestAvailableLocale(refLocale) {
  if (refLocale == null)
    return null;
  const relatedLocales = getPossibleLocales(refLocale);
  for (let i = 0; i < relatedLocales.length; i++) {
    const locale = relatedLocales[i];
    if (hasLocaleDictionary(locale)) {
      return locale;
    }
  }
  return null;
}
function addMessages(locale, ...partials) {
  $dictionary.update((d) => {
    d[locale] = Object.assign(d[locale] || {}, ...partials);
    return d;
  });
}
var $locales = derived([$dictionary], ([$dictionary2]) => Object.keys($dictionary2));
$dictionary.subscribe((newDictionary) => dictionary = newDictionary);

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/stores/loading.js
var $isLoading = writable(false);

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/loaderQueue.js
var loaderQueue = {};
function createLocaleQueue(locale) {
  loaderQueue[locale] = /* @__PURE__ */ new Set();
}
function removeLocaleFromQueue(locale) {
  delete loaderQueue[locale];
}
function getLocaleQueue(locale) {
  return loaderQueue[locale];
}
function getLocalesQueues(locale) {
  return getPossibleLocales(locale).reverse().map((localeItem) => {
    const queue = getLocaleQueue(localeItem);
    return [localeItem, queue ? [...queue] : []];
  }).filter(([, queue]) => queue.length > 0);
}
function hasLocaleQueue(locale) {
  return getPossibleLocales(locale).reverse().some(getLocaleQueue);
}
var activeLocaleFlushes = {};
function flush(locale) {
  if (!hasLocaleQueue(locale))
    return Promise.resolve();
  if (locale in activeLocaleFlushes)
    return activeLocaleFlushes[locale];
  const queues = getLocalesQueues(locale);
  if (queues.length === 0)
    return Promise.resolve();
  const loadingDelay = setTimeout(() => $isLoading.set(true), getOptions().loadingDelay);
  activeLocaleFlushes[locale] = Promise.all(queues.map(([locale2, queue]) => {
    return Promise.all(queue.map((loader) => loader())).then((partials) => {
      removeLocaleFromQueue(locale2);
      partials = partials.map((partial) => partial.default || partial);
      addMessages(locale2, ...partials);
    });
  })).then(() => {
    clearTimeout(loadingDelay);
    $isLoading.set(false);
    delete activeLocaleFlushes[locale];
  });
  return activeLocaleFlushes[locale];
}
function registerLocaleLoader(locale, loader) {
  if (!getLocaleQueue(locale))
    createLocaleQueue(locale);
  const queue = getLocaleQueue(locale);
  if (getLocaleQueue(locale).has(loader))
    return;
  if (!hasLocaleDictionary(locale)) {
    $dictionary.update((d) => {
      d[locale] = {};
      return d;
    });
  }
  queue.add(loader);
}

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/localeGetters.js
var getFromQueryString = (queryString, key) => {
  const keyVal = queryString.split("&").find((i) => i.indexOf(`${key}=`) === 0);
  if (keyVal) {
    return keyVal.split("=").pop() || null;
  }
  return null;
};
var getFirstMatch = (base, pattern) => {
  const match = pattern.exec(base);
  if (!match)
    return null;
  return match[1] || null;
};
var getLocaleFromHostname = (hostname) => {
  if (typeof window === "undefined")
    return null;
  return getFirstMatch(window.location.hostname, hostname);
};
var getLocaleFromPathname = (pathname) => {
  if (typeof window === "undefined")
    return null;
  return getFirstMatch(window.location.pathname, pathname);
};
var getLocaleFromNavigator = (ssrDefault) => {
  if (typeof window === "undefined") {
    return ssrDefault || null;
  }
  return window.navigator.language || window.navigator.languages[0];
};
var getLocaleFromQueryString = (search) => {
  if (typeof window === "undefined")
    return null;
  return getFromQueryString(window.location.search.substr(1), search);
};
var getLocaleFromHash = (hash) => {
  if (typeof window === "undefined")
    return null;
  return getFromQueryString(window.location.hash.substr(1), hash);
};
var getLocaleFromAcceptLanguageHeader = (header, availableLocales) => {
  if (!header)
    return void 0;
  const locales = header.split(",").map((locale) => locale.trim()).map((locale) => {
    const directives = locale.split(";q=");
    return {
      locale: directives[0],
      quality: parseFloat(directives[1]) || 1
    };
  }).sort((a, b) => b.quality - a.quality);
  if (!availableLocales || availableLocales.length === 0)
    return locales[0].locale;
  locales.forEach((l) => l.locale = l.locale.toLowerCase());
  let firstAvailableBaseMatch;
  for (const locale of locales) {
    if (firstAvailableBaseMatch && !locale.locale.toLowerCase().startsWith(`${firstAvailableBaseMatch.base}-`)) {
      continue;
    }
    const fullMatch = getArrayElementCaseInsensitive(availableLocales, locale.locale);
    if (fullMatch) {
      return fullMatch;
    }
    if (firstAvailableBaseMatch) {
      continue;
    }
    const baseMatch = getArrayElementCaseInsensitive(availableLocales, locale.locale.split("-")[0]);
    if (baseMatch) {
      return baseMatch;
    }
    for (const availableLocale of availableLocales) {
      const availableBase = availableLocale.split("-")[0];
      if (availableBase.toLowerCase() === locale.locale) {
        firstAvailableBaseMatch = {
          match: availableLocale,
          base: locale.locale
        };
        break;
      }
    }
  }
  if (firstAvailableBaseMatch !== void 0) {
    return firstAvailableBaseMatch.match;
  }
  return void 0;
};
function getArrayElementCaseInsensitive(array, searchElement) {
  searchElement = searchElement.toLowerCase();
  for (const element of array) {
    if (element.toLowerCase() === searchElement) {
      return element;
    }
  }
  return void 0;
}

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/stores/locale.js
var $locale = writable("");
$locale.subscribe((newLocale) => {
  setCurrentLocale(newLocale);
  if (typeof window !== "undefined") {
    if (newLocale !== "") {
      document.documentElement.setAttribute("lang", newLocale);
    }
  }
});
var localeSet = $locale.set;
$locale.set = (newLocale) => {
  if (getClosestAvailableLocale(newLocale) && hasLocaleQueue(newLocale)) {
    return flush(newLocale).then(() => localeSet(newLocale));
  }
  return localeSet(newLocale);
};
$locale.update = (fn) => {
  let currentLocale2 = getCurrentLocale();
  fn(currentLocale2);
  localeSet(currentLocale2);
};

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/configs.js
function init(opts) {
  const { formats, ...rest } = opts;
  const initialLocale = opts.initialLocale || opts.fallbackLocale;
  const options2 = getOptions();
  Object.assign(options2, rest, { initialLocale });
  if (formats) {
    if ("number" in formats) {
      Object.assign(options2.formats.number, formats.number);
    }
    if ("date" in formats) {
      Object.assign(options2.formats.date, formats.date);
    }
    if ("time" in formats) {
      Object.assign(options2.formats.time, formats.time);
    }
  }
  return $locale.set(initialLocale);
}

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/lookup.js
var lookupCache = {};
var addToCache = (path, locale, message) => {
  if (!message)
    return message;
  if (!(locale in lookupCache))
    lookupCache[locale] = {};
  if (!(path in lookupCache[locale]))
    lookupCache[locale][path] = message;
  return message;
};
var lookup = (path, refLocale) => {
  if (refLocale == null)
    return void 0;
  if (refLocale in lookupCache && path in lookupCache[refLocale]) {
    return lookupCache[refLocale][path];
  }
  const locales = getPossibleLocales(refLocale);
  for (let i = 0; i < locales.length; i++) {
    const locale = locales[i];
    const message = getMessageFromDictionary(locale, path);
    if (message) {
      return addToCache(path, refLocale, message);
    }
  }
  return void 0;
};

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/memoize.js
var monadicMemoize = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  const memoizedFn = (arg) => {
    const cacheKey = JSON.stringify(arg);
    if (!(cacheKey in cache)) {
      cache[cacheKey] = fn(arg);
    }
    return cache[cacheKey];
  };
  return memoizedFn;
};

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/includes/formatters.js
var getIntlFormatterOptions = (type, name) => {
  const { formats } = getOptions();
  if (type in formats && name in formats[type]) {
    return formats[type][name];
  }
  throw new Error(`[precompile-intl-runtime] Unknown "${name}" ${type} format.`);
};
var getNumberFormatter = monadicMemoize(({ locale, format, ...options2 } = {}) => {
  locale = locale || getCurrentLocale();
  if (locale == null) {
    throw new Error('[precompile-intl-runtime] A "locale" must be set to format numbers');
  }
  if (typeof format === "string") {
    return new Intl.NumberFormat(locale, getIntlFormatterOptions("number", format));
  } else {
    return new Intl.NumberFormat(locale, options2);
  }
});
var getDateFormatter = monadicMemoize(({ locale, format, ...options2 } = {}) => {
  locale = locale || getCurrentLocale();
  if (locale == null) {
    throw new Error('[precompile-intl-runtime] A "locale" must be set to format dates');
  }
  if (format) {
    options2 = getIntlFormatterOptions("date", format);
  } else if (Object.keys(options2).length === 0) {
    options2 = getIntlFormatterOptions("date", "short");
  }
  return new Intl.DateTimeFormat(locale, options2);
});
var getTimeFormatter = monadicMemoize(({ locale, format, ...options2 } = {}) => {
  locale = locale || getCurrentLocale();
  if (locale == null) {
    throw new Error('[precompile-intl-runtime] A "locale" must be set to format time values');
  }
  if (format) {
    options2 = getIntlFormatterOptions("time", format);
  } else if (Object.keys(options2).length === 0) {
    options2 = getIntlFormatterOptions("time", "short");
  }
  return new Intl.DateTimeFormat(locale, options2);
});

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/stores/formatters.js
var formatMessage = (currentLocale2, optionsOrId, maybeOptions = {}) => {
  const id = typeof optionsOrId === "string" ? optionsOrId : optionsOrId.id;
  const options2 = typeof optionsOrId === "string" ? maybeOptions : optionsOrId;
  const { values, locale = currentLocale2 || getCurrentLocale(), default: defaultValue } = options2;
  if (locale == null) {
    throw new Error("[svelte-intl-precompile] Cannot format a message without first setting the initial locale.");
  }
  let message = lookup(id, locale);
  if (typeof message === "string") {
    return message;
  }
  if (typeof message === "function") {
    return message(...Object.keys(options2.values || {}).sort().map((k) => (options2.values || {})[k]));
  }
  if (getOptions().warnOnMissingMessages) {
    console.warn(`[svelte-intl-precompile] The message "${id}" was not found in "${getPossibleLocales(locale).join('", "')}".${hasLocaleQueue(getCurrentLocale()) ? `

Note: there are at least one loader still registered to this locale that wasn't executed.` : ""}`);
  }
  return defaultValue || id;
};
var getJSON = (id, locale) => {
  locale = locale || getCurrentLocale();
  return lookup(id, locale) || id;
};
var formatTime = (currentLocale2, t, options2) => {
  const locale = currentLocale2 || getCurrentLocale();
  return getTimeFormatter({ locale, ...options2 }).format(t);
};
var formatDate = (currentLocale2, d, options2) => {
  const locale = currentLocale2 || getCurrentLocale();
  return getDateFormatter({ locale, ...options2 }).format(d);
};
var formatNumber = (currentLocale2, n, options2) => {
  const locale = currentLocale2 || getCurrentLocale();
  return getNumberFormatter({ locale, ...options2 }).format(n);
};
var $format = derived([$locale, $dictionary], ([currentLocale2]) => formatMessage.bind(null, currentLocale2));
var $formatTime = derived([$locale], ([currentLocale2]) => formatTime.bind(null, currentLocale2));
var $formatDate = derived([$locale], ([currentLocale2]) => formatDate.bind(null, currentLocale2));
var $formatNumber = derived([$locale], ([currentLocale2]) => formatNumber.bind(null, currentLocale2));
var $getJSON = derived([$locale, $dictionary], () => getJSON);

// node_modules/svelte-intl-precompile/node_modules/precompile-intl-runtime/dist/modules/index.js
function waitLocale(locale) {
  return flush(locale || getCurrentLocale() || getOptions().initialLocale);
}
function __interpolate(value) {
  return value === 0 ? 0 : value || "";
}
var PLURAL_RULES = /* @__PURE__ */ Object.create(null);
function getLocalPluralFor(v) {
  let loc = getCurrentLocale();
  let pluralRules = PLURAL_RULES[loc] || (PLURAL_RULES[loc] = new Intl.PluralRules(loc));
  let key = pluralRules.select(v);
  return key === "other" ? "h" : key[0];
}
function __offsetPlural(value, offset, opts) {
  return opts[value] || opts[getLocalPluralFor(value - offset)] || "";
}
function __plural(value, opts) {
  return opts[value] || opts[getLocalPluralFor(value)] || "";
}
function __select(value, opts) {
  return opts[value] || opts["other"] || "";
}
function __number(value, format) {
  return formatNumber(getCurrentLocale(), value, typeof format === "string" ? { format } : format);
}
function __date(value, format = "short") {
  return formatDate(getCurrentLocale(), value, { format });
}
function __time(value, format = "short") {
  return formatTime(getCurrentLocale(), value, { format });
}
export {
  $format as _,
  __date,
  __interpolate,
  __number,
  __offsetPlural,
  __plural,
  __select,
  __time,
  addMessages,
  $formatDate as date,
  defaultFormats,
  $dictionary as dictionary,
  $format as format,
  formatMessage,
  getCurrentLocale,
  getDateFormatter,
  getLocaleFromAcceptLanguageHeader,
  getLocaleFromHash,
  getLocaleFromHostname,
  getLocaleFromNavigator,
  getLocaleFromPathname,
  getLocaleFromQueryString,
  getNumberFormatter,
  getOptions,
  getPossibleLocales,
  getTimeFormatter,
  init,
  $isLoading as isLoading,
  $getJSON as json,
  $locale as locale,
  $locales as locales,
  $formatNumber as number,
  registerLocaleLoader as register,
  setCurrentLocale,
  $format as t,
  $formatTime as time,
  waitLocale
};
//# sourceMappingURL=svelte-intl-precompile.js.map
